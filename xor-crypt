//
// Created by imper on 10/10/21.
//

#ifndef XOR_CRYPT
#define XOR_CRYPT

#include <string>
#include <unistd.h>
#include <stdexcept>
#include <log-console>
#include <cstring>
#include <sys/ioctl.h>
#include <sys/stat.h>

#define log (_log << log_console::l_lock << log_console::l_localtime << l_location << color::yellow)
#define err (_err << log_console::l_lock << log_console::l_localtime << l_location << color::red)

#define endline color::reset << log_console::l_endent

#define encrypt_byte(elem, password, iterator, max_iterator) { elem ^= password[iterator++]; iterator %= max_iterator; }

typedef unsigned char byte;
typedef unsigned long size_t;

template <typename string_t>
concept string_type = std::is_same_v<string_t, std::string> || std::is_same_v<string_t, std::wstring>;


template <character char_t>
static inline constexpr size_t char_t_strlen(const char_t* str)
{
	size_t size = 0;
	for (; *str; ++size, ++str);
	return size;
}

static inline constexpr byte* copy_data(const void* data, size_t size)
{
	auto* tmp = static_cast<const byte*>(data);
	auto* res = size ? new byte[size] : nullptr;
	
	for (size_t i = 0; i < size; ++i)
		res[i] = tmp[i];
	
	return res;
}

static inline constexpr byte* copy_data_to(const void* data, byte* to, size_t size)
{
	auto* tmp = static_cast<const byte*>(data);
	if (data == to) return to;
	
	for (size_t i = 0; i < size; ++i)
		to[i] = tmp[i];
	
	return to;
}


class buffer
{
public:
	explicit inline buffer();
	
	explicit inline buffer(void* buffer, size_t size);
	
	explicit inline buffer(size_t size);
	
	inline buffer(const buffer& another);
	
	inline buffer(buffer&& another) noexcept;
	
	[[nodiscard]] inline size_t capacity() const;
	
	inline void realloc(size_t size);
	
	inline void dealloc();
	
	[[nodiscard]] inline void* clone_mem() const;
	
	inline size_t clone_mem(void* res, size_t size) const;
	
	[[nodiscard]] inline const void* get() const;
	
	[[nodiscard]] inline void* abort_mem();
	
	inline void from(const void* data, size_t size);
	
	inline void take(void* data, size_t size);

private:
	byte* m_mem;
	size_t m_capacity;
};

inline buffer::buffer() : m_mem(nullptr), m_capacity(0)
{ }

inline buffer::buffer(size_t size) : m_mem(new byte[size]), m_capacity(size)
{ }

inline buffer::buffer(void* buffer, size_t size) : m_mem(static_cast<byte*>(buffer)), m_capacity(size)
{ }

inline buffer::buffer(const buffer& another) : m_mem(copy_data(another.m_mem, another.m_capacity)), m_capacity(another.m_capacity)
{ }

inline buffer::buffer(buffer&& another) noexcept: m_mem(another.m_mem), m_capacity(another.m_capacity)
{
	another.m_capacity = 0;
	another.m_mem = nullptr;
}

inline size_t buffer::capacity() const
{
	return this->m_capacity;
}

inline void buffer::realloc(size_t size)
{
	delete[] this->m_mem;
	this->m_capacity = size;
	this->m_mem = new byte[size];
}

inline void buffer::dealloc()
{
	delete[] this->m_mem;
	this->m_capacity = 0;
	this->m_mem = nullptr;
}

inline void* buffer::clone_mem() const
{
	return copy_data(this->m_mem, this->m_capacity);
}

inline size_t buffer::clone_mem(void* res, size_t size) const
{
	size_t ret_size = std::min(size, this->m_capacity);
	copy_data_to(this->m_mem, static_cast<byte*>(res), ret_size);
	return ret_size;
}

inline const void* buffer::get() const
{
	return this->m_mem;
}

inline void* buffer::abort_mem()
{
	void* res = this->m_mem;
	this->m_capacity = 0;
	this->m_mem = nullptr;
	return res;
}

inline void buffer::from(const void* data, size_t size)
{
	delete[] this->m_mem;
	this->m_capacity = size;
	this->m_mem = copy_data(data, size);
}

inline void buffer::take(void* data, size_t size)
{
	delete[] this->m_mem;
	this->m_capacity = size;
	this->m_mem = static_cast<byte*>(data);
}


class source
{
public:
	source(const source&) = delete;
	
	source(source&&) = default;
	
	[[nodiscard]] ssize_t get_last_read() const;
	
	operator bool() const;
	
	virtual size_t available() = 0;
	
	virtual ssize_t read(void* data, size_t size);
	
	void close();

protected:
	friend class xor_decrypt;
	
	ssize_t last_read = -1;
	int fd;
	
	explicit source(int fd) : fd(fd)
	{ }
	
	static log_console _log;
	static log_console _err;
};

log_console source::_log(stdout);
log_console source::_err(stderr);

ssize_t source::get_last_read() const
{
	return this->last_read;
}

source::operator bool() const
{
	return this->last_read > 0;
}

ssize_t source::read(void* data, size_t size)
{
	ssize_t read = ::read(this->fd, data, size);
	this->last_read = read;
	if (read < 0)
	{
		char error[128];
		::strerror_r(errno, error, 128);
		err << "error " << errno << " in read() " << color::italic << error << endline;
	}
	return read;
}

void source::close()
{
	if (this->fd > 0)
	{
		if (::close(this->fd) < 0)
		{
			char error[128];
			::strerror_r(errno, error, 128);
			err << "error " << errno << " in close() " << color::italic << error << endline;
		}
		this->fd = -1;
	}
}


class empty_source : public source
{
public:
	empty_source() : source(-1)
	{ }
	
	size_t available() override
	{
		return 0;
	}
	
	ssize_t read(void*, size_t) override
	{
		this->last_read = -1;
		return -1;
	}
};


class file_source : public source
{
public:
	explicit file_source(FILE* file_ptr) : source(file_ptr->_fileno)
	{ }
	
	explicit file_source(const char* filename) : file_source(::fopen(filename, "rb"))
	{ }
	
	explicit file_source(const std::string& filename) : file_source(filename.c_str())
	{ }
	
	[[nodiscard]] size_t available() override
	{
		struct stat st{ };
		::fstat(this->fd, &st);
		return st.st_size;
	}
	
	ssize_t read(void* data, size_t size) override
	{
		return source::read(data, size);
	}
};


class stream_source : public source
{
public:
	explicit stream_source(int stream_fd) : source(stream_fd)
	{ }
	
	explicit stream_source(FILE* stream_ptr) : stream_source(stream_ptr->_fileno)
	{ }
	
	[[nodiscard]] size_t available() override
	{
		long available;
		::ioctl(this->fd, FIONREAD, &available);
		if (available <= 0)
		{
			::ioctl(this->fd, FIOQSIZE, &available);
		}
		return available;
	}
	
	ssize_t read(void* data, size_t size) override
	{
		return source::read(data, size);
	}
};


class buffer_source : public source
{
public:
	explicit buffer_source(const buffer& buffer) : source(-1), buf(buffer)
	{ }
	
	[[nodiscard]] size_t available() override
	{
		return this->buf.capacity();
	}
	
	ssize_t read(void* data, size_t size) override
	{
		return this->buf.clone_mem(data, size);
	}

private:
	const buffer& buf;
};


class destination
{
public:
	
	destination(const destination&) = delete;
	
	destination(destination&&) = default;
	
	[[nodiscard]] ssize_t get_last_write() const;
	
	operator bool() const;
	
	virtual ssize_t write(const void* data, size_t size);
	
	void close();

protected:
	friend class xor_encrypt;
	
	ssize_t last_write = -1;
	int fd;
	
	explicit destination(int fd) : fd(fd)
	{ }
	
	static log_console _log;
	static log_console _err;
};

log_console destination::_log(stdout);
log_console destination::_err(stderr);

ssize_t destination::get_last_write() const
{
	return this->last_write;
}

destination::operator bool() const
{
	return this->last_write > 0;
}

ssize_t destination::write(const void* data, size_t size)
{
	ssize_t wrote = ::write(this->fd, data, size);
	this->last_write = wrote;
	if (wrote < 0)
	{
		char error[128];
		::strerror_r(errno, error, 128);
		err << "error " << errno << " in write() " << color::italic << error << endline;
	}
	return wrote;
}

void destination::close()
{
	if (this->fd > 0)
	{
		if (::close(this->fd) < 0)
		{
			char error[128];
			::strerror_r(errno, error, 128);
			err << "error " << errno << " in close() " << color::italic << error << endline;
		}
		this->fd = -1;
	}
}


class empty_destination : public destination
{
public:
	empty_destination() : destination(-1)
	{ }
	
	ssize_t write(const void*, size_t) override
	{
		this->last_write = -1;
		return -1;
	}
};


class file_destination : public destination
{
public:
	explicit file_destination(FILE* file_ptr) : destination(file_ptr->_fileno)
	{ }
	
	explicit file_destination(const char* filename) : file_destination(::fopen(filename, "wb"))
	{ }
	
	explicit file_destination(const std::string& filename) : file_destination(filename.c_str())
	{ }
	
	ssize_t write(const void* data, size_t size) override
	{
		return destination::write(data, size);
	}
};


class stream_destination : public destination
{
public:
	explicit stream_destination(int stream_fd) : destination(stream_fd)
	{ }
	
	explicit stream_destination(FILE* stream_ptr) : stream_destination(stream_ptr->_fileno)
	{ }
	
	ssize_t write(const void* data, size_t size) override
	{
		return destination::write(data, size);
	}
};


class buffer_destination : public destination
{
public:
	explicit buffer_destination(buffer& buffer) : destination(-1), buf(buffer)
	{ }
	
	ssize_t write(const void* data, size_t size) override
	{
		this->buf.take(const_cast<void*>(data), size);
		this->last_write = size;
		return size;
	}

private:
	buffer& buf;
};


class xor_crypt
{
public:
	void set_password(const void* password, size_t size);
	
	void reset_iter();

protected:
	xor_crypt(const void* password, size_t size);
	
	xor_crypt(const xor_crypt& xc);
	
	xor_crypt(xor_crypt&& xc) noexcept;
	
	byte* passwd;
	size_t passwd_size;
	size_t passwd_iter{ };
};

xor_crypt::xor_crypt(const void* password, size_t size) : passwd(copy_data(password, size)), passwd_size(size)
{ }

xor_crypt::xor_crypt(const xor_crypt& xc) : passwd(::copy_data(xc.passwd, xc.passwd_size)), passwd_size(xc.passwd_size),
											passwd_iter(xc.passwd_iter)
{ }

xor_crypt::xor_crypt(xor_crypt&& xc) noexcept: passwd(xc.passwd), passwd_size(xc.passwd_size), passwd_iter(xc.passwd_iter)
{
	xc.passwd = nullptr;
	xc.passwd_size = 0;
	xc.passwd_iter = 0;
}

void xor_crypt::set_password(const void* password, size_t size)
{
	this->passwd = copy_data(password, size);
	this->passwd_size = size;
}

void xor_crypt::reset_iter()
{
	this->passwd_iter = 0;
}


class xor_decrypt : public xor_crypt
{
public:
	xor_decrypt(const void* password, size_t size, source& source);
	
	xor_decrypt(const std::string& password, source& source);
	
	xor_decrypt(const xor_decrypt& xd) = default;
	
	xor_decrypt(xor_decrypt&& xd) noexcept;
	
	ssize_t read(void* data, size_t size);
	
	void set_source(source* src);
	
	size_t available() const;
	
	void close_fd();

private:
	source* src;
};

xor_decrypt::xor_decrypt(const void* password, size_t size, source& source = *new empty_source) : xor_crypt(password, size), src(&source)
{ }

xor_decrypt::xor_decrypt(const std::string& password, source& source = *new empty_source) : xor_decrypt(password.c_str(), password.size(), source)
{ }

xor_decrypt::xor_decrypt(xor_decrypt&& xd) noexcept: xor_crypt(std::move(xd)), src(xd.src)
{
	xd.src = nullptr;
}

ssize_t xor_decrypt::read(void* data, size_t size)
{
	ssize_t res = src->read(data, size);
	
	for (byte* i = static_cast<byte*>(data); i < static_cast<byte*>(data) + res; ++i)
	encrypt_byte(*i, this->passwd, this->passwd_iter, this->passwd_size)
	
	return res;
}

void xor_decrypt::set_source(source* src)
{
	this->src = src;
}

size_t xor_decrypt::available() const
{
	return this->src->available();
}

void xor_decrypt::close_fd()
{
	src->close();
}

inline xor_decrypt& operator>>(const char* source_name, xor_decrypt& xd)
{
	xd.set_source(new file_source(source_name));
	return xd;
}

inline xor_decrypt& operator>>(const std::string& source_name, xor_decrypt& xd)
{
	xd.set_source(new file_source(source_name));
	return xd;
}

inline xor_decrypt& operator>>(const buffer& source_buf, xor_decrypt& xd)
{
	xd.set_source(new buffer_source(source_buf));
	return xd;
}

inline xor_decrypt& operator>>(FILE* source_file, xor_decrypt& xd)
{
	xd.set_source(new file_source(source_file));
	return xd;
}

inline xor_decrypt& operator>>(int source_fd, xor_decrypt& xd)
{
	xd.set_source(new stream_source(source_fd));
	return xd;
}

inline xor_decrypt& operator>>(xor_decrypt& xd, std::string& res)
{
	size_t size = xd.available();
	res.resize(size);
	char* data = res.data();
	xd.read(data, size);
	return xd;
}

inline xor_decrypt& operator>>(xor_decrypt& xd, buffer& res)
{
	size_t size = xd.available();
	auto* data = new byte[size];
	xd.read(data, size);
	res.take(data, size);
	return xd;
}


class xor_encrypt : public xor_crypt
{
public:
	xor_encrypt(const void* password, size_t size, destination& destination);
	
	xor_encrypt(const std::string& password, destination& destination);
	
	xor_encrypt(const xor_encrypt& xe) = default;
	
	xor_encrypt(xor_encrypt&& xe)  noexcept;
	
	ssize_t write(const void* data, size_t size);
	
	void set_destination(destination* dest);
	
	void close_fd();

private:
	destination* dest;
};

xor_encrypt::xor_encrypt(const void* password, size_t size, destination& destination = *new empty_destination) : xor_crypt(password, size),
																												 dest(&destination)
{ }

xor_encrypt::xor_encrypt(const std::string& password, destination& destination = *new empty_destination) :
		xor_encrypt(password.c_str(), password.size(), destination)
{ }

xor_encrypt::xor_encrypt(xor_encrypt&& xe) noexcept: xor_crypt(std::move(xe)), dest(xe.dest)
{
	xe.dest = nullptr;
}

ssize_t xor_encrypt::write(const void* data, size_t size)
{
	auto* tmp = copy_data(data, size);
	
	for (decltype(tmp) i = tmp; i < tmp + size; ++i)
	encrypt_byte(*i, this->passwd, this->passwd_iter, this->passwd_size)
	
	return dest->write(tmp, size);
}

void xor_encrypt::set_destination(destination* dest)
{
	this->dest = dest;
}

void xor_encrypt::close_fd()
{
	this->dest->close();
}

inline xor_encrypt& operator<<(const char* dest_name, xor_encrypt& xe)
{
	xe.set_destination(new file_destination(dest_name));
	return xe;
}

inline xor_encrypt& operator<<(const std::string& dest_name, xor_encrypt& xe)
{
	xe.set_destination(new file_destination(dest_name));
	return xe;
}

inline xor_encrypt& operator<<(buffer& dest_buf, xor_encrypt& xe)
{
	xe.set_destination(new buffer_destination(dest_buf));
	return xe;
}

inline xor_encrypt& operator<<(FILE* dest_file, xor_encrypt& xe)
{
	xe.set_destination(new file_destination(dest_file));
	return xe;
}

inline xor_encrypt& operator<<(int dest_fd, xor_encrypt& xe)
{
	xe.set_destination(new stream_destination(dest_fd));
	return xe;
}

template <character char_t>
inline xor_encrypt& operator<<(xor_encrypt& xe, const std::basic_string<char_t>& data)
{
	xe.write(data.c_str(), data.size() * sizeof(char_t));
	return xe;
}

template <character char_t>
inline xor_encrypt& operator<<(xor_encrypt& xe, const char_t* data)
{
	xe.write(data, static_strlen(data) * sizeof(char_t));
	return xe;
}

inline xor_encrypt& operator<<(xor_encrypt& xe, const buffer& data)
{
	xe.write(data.get(), data.capacity());
	return xe;
}

#endif //XOR_CRYPT
